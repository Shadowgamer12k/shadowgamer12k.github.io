<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Endless Chicken Runner | shadowGamer100k</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky Blue */
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Prevent zoom/scroll on mobile */
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        /* Background Layers (Parallax) */
        .bg-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background-repeat: repeat-x;
        }

        #sky { background: linear-gradient(#87CEEB, #E0F6FF); z-index: -3; }
        
        /* Simple pixel clouds using CSS shadows or images could go here, using emoji for simplicity */
        .cloud {
            position: absolute;
            font-size: 60px;
            color: rgba(255,255,255,0.8);
            z-index: -2;
        }

        #ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100px;
            background-image: url('data:image/svg+xml;utf8,<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect width="40" height="40" fill="%235C4033"/><rect x="0" y="0" width="40" height="10" fill="%232E8B57"/></svg>'); /* Dirt with grass top */
            z-index: 1;
        }

        /* Game UI */
        #uiLayer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
            font-size: 20px;
        }

        #score { color: #FFD700; }
        #highScore { font-size: 12px; color: #ddd; margin-top: 5px; }

        /* Entities */
        .entity {
            position: absolute;
            font-size: 40px;
            z-index: 5;
            transform-origin: center bottom;
        }

        #player {
            bottom: 100px; /* On top of ground */
            left: 50px;
            transition: transform 0.1s;
        }

        .obstacle {
            bottom: 100px;
        }

        /* Game Over Screen */
        #gameOverScreen {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 20;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
        }

        #gameOverScreen h1 { color: #FF5555; font-size: 40px; margin-bottom: 20px; text-shadow: 4px 4px 0 #000; }
        
        .btn {
            background: #222;
            color: white;
            border: 4px solid #fff;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .btn:hover { transform: scale(1.1); background: #444; }
        .btn:active { transform: scale(0.9); }

        .particle {
            position: absolute;
            pointer-events: none;
            background: white;
            width: 8px;
            height: 8px;
            z-index: 6;
        }

        /* Mobile Jump Button */
        #mobileJumpBtn {
            display: none;
            position: absolute;
            bottom: 20px; right: 20px;
            width: 80px; height: 80px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            border: 4px solid white;
            z-index: 15;
        }
        @media (max-width: 768px) {
            #mobileJumpBtn { display: block; }
        }

        .back-btn {
            position: absolute;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-decoration: none;
            font-size: 12px;
            z-index: 20;
            border: 2px solid #fff;
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <!-- Back to Home -->
        <a href="https://shadowgamer12k.github.io/" class="back-btn"><i class="fas fa-home"></i> HOME</a>

        <!-- UI -->
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="highScore">HI: 0</div>
        </div>

        <!-- Game World -->
        <div id="sky"></div>
        <!-- Clouds generated by JS -->
        <div id="ground"></div>
        
        <!-- Player -->
        <div id="player" class="entity">üêî</div>

        <!-- Mobile Controls -->
        <div id="mobileJumpBtn"></div>

        <!-- Game Over Overlay -->
        <div id="gameOverScreen">
            <h1>GAME OVER!</h1>
            <p style="margin-bottom: 20px; font-size: 14px;">You hit something!</p>
            <div style="font-size: 20px; color: #FFD700; margin-bottom: 30px;">Score: <span id="finalScore">0</span></div>
            
            <button class="btn" onclick="resetGame()">RETRY ‚Üª</button>
            <a href="https://shadowgamer12k.github.io/" class="btn" style="text-decoration: none; font-size: 14px;">EXIT ‚ûú</a>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const GROUND_Y = 100; // Height of ground from bottom
        const START_SPEED = 5;
        const MAX_SPEED = 15;
        const SPEED_INC = 0.001;

        // --- STATE ---
        let gameRunning = true;
        let score = 0;
        let gameSpeed = START_SPEED;
        let highScore = localStorage.getItem('chickenHighScore') || 0;
        
        // Player
        const player = {
            elem: document.getElementById('player'),
            y: 0,
            dy: 0,
            isGrounded: true,
            width: 40,
            height: 40
        };

        // Arrays
        let obstacles = [];
        let clouds = [];
        let particles = [];

        // Elements
        const container = document.getElementById('gameContainer');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverScreen = document.getElementById('gameOverScreen');

        // Initialize
        highScoreEl.innerText = `HI: ${Math.floor(highScore)}`;

        // --- INPUT ---
        function jump() {
            if (player.isGrounded && gameRunning) {
                player.dy = JUMP_FORCE;
                player.isGrounded = false;
                createParticles(50, window.innerHeight - GROUND_Y, 'jump');
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') jump();
        });
        
        document.addEventListener('touchstart', (e) => {
            if(e.target.closest('.btn')) return; // Don't jump if clicking buttons
            jump();
        });

        document.getElementById('mobileJumpBtn').addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent double firing
            jump();
        });

        // --- GAME LOOP ---
        function update() {
            if (!gameRunning) return;

            // 1. Update Score & Speed
            score += 0.1;
            if (gameSpeed < MAX_SPEED) gameSpeed += SPEED_INC;
            scoreEl.innerText = `SCORE: ${Math.floor(score)}`;

            // 2. Player Physics
            player.dy += GRAVITY;
            player.y += player.dy;

            // Ground Collision
            if (player.y > 0) { // 0 is relative to ground level in CSS (bottom: 100px + y)
                player.y = 0;
                player.dy = 0;
                player.isGrounded = true;
            }

            // Apply Visual Position
            // Note: CSS bottom is 100px (ground height) - y (inverted because positive y goes down in physics usually, but here I made y=0 ground)
            // Let's fix logic: y=0 is ground. Jump makes y negative? No, usually jump increases Y in DOM "bottom".
            // Let's invert: y=0 is ground. Jump increases y. Gravity decreases y.
            
            // Correction: 
            // Jump: dy = positive
            // Gravity: dy -= gravity
            // if y <= 0 -> grounded.
            // Let's redo simple logic for CSS 'bottom'.
            
            // Current Logic:
            // y starts at 0.
            // Jump makes dy = 15.
            // Loop: y += dy. dy -= gravity.
            // if y < 0, y = 0, grounded = true.
            
            // Wait, standard physics:
            // dy += gravity (gravity is negative? or positive pointing down?)
            // CSS 'bottom': higher value = higher up.
            
            // Let's use:
            // y = 0 (on ground).
            // Jump: dy = 15.
            // Frame: y += dy. dy -= 0.6.
            // if y < 0 -> y=0, grounded.
            
            // Re-writing logic inside update to be safe:
            player.y += player.dy; // Apply velocity
            
            // Apply Gravity (downwards)
            // Since we use 'bottom', pulling down means decreasing Y.
            // So gravity should decrease dy.
            if(!player.isGrounded) player.dy -= GRAVITY; 
            
            // Check Floor
            if (player.y <= 0) {
                player.y = 0;
                player.dy = 0;
                player.isGrounded = true;
            } else {
                player.isGrounded = false;
            }
            
            player.elem.style.bottom = `${GROUND_Y + player.y}px`;
            
            // Rotation effect when jumping
            if(!player.isGrounded) {
                player.elem.style.transform = `rotate(${player.dy * -2}deg)`;
            } else {
                player.elem.style.transform = `rotate(0deg)`;
            }

            // 3. Obstacle Spawning & Logic
            if (Math.random() < 0.015 + (gameSpeed * 0.0005)) spawnObstacle();

            obstacles.forEach((obs, index) => {
                obs.x -= gameSpeed;
                obs.elem.style.left = `${obs.x}px`;

                // Collision Detection
                // Player Rect (simplified)
                const pLeft = 50 + 10; // padding
                const pRight = 50 + 40 - 10;
                const pBottom = GROUND_Y + player.y;
                const pTop = pBottom + 40;

                const oLeft = obs.x + 5;
                const oRight = obs.x + 40 - 5;
                const oBottom = GROUND_Y;
                const oTop = oBottom + 40; // Assume mostly square hitboxes

                if (pRight > oLeft && pLeft < oRight && pBottom < oTop) {
                    gameOver();
                }

                // Remove if off screen
                if (obs.x < -50) {
                    obs.elem.remove();
                    obstacles.splice(index, 1);
                }
            });

            // 4. Clouds (Parallax)
            if (Math.random() < 0.01) spawnCloud();
            clouds.forEach((c, i) => {
                c.x -= gameSpeed * 0.2; // Slower
                c.elem.style.left = `${c.x}px`;
                if(c.x < -100) {
                    c.elem.remove();
                    clouds.splice(i, 1);
                }
            });

            requestAnimationFrame(update);
        }

        // --- HELPERS ---
        function spawnObstacle() {
            // Don't spawn too close
            if (obstacles.length > 0 && obstacles[obstacles.length-1].x > window.innerWidth - 300) return;

            const types = ['üåµ', 'ü¶ä', 'üî•', 'üß±'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const el = document.createElement('div');
            el.classList.add('entity', 'obstacle');
            el.innerText = type;
            el.style.left = '100vw';
            container.appendChild(el);

            obstacles.push({
                x: window.innerWidth,
                elem: el,
                type: type
            });
        }

        function spawnCloud() {
            const el = document.createElement('div');
            el.classList.add('cloud');
            el.innerText = '‚òÅÔ∏è';
            el.style.top = `${Math.random() * 50}%`;
            el.style.left = '100vw';
            el.style.opacity = Math.random() * 0.5 + 0.3;
            const size = Math.random() * 2 + 1; // Scale
            el.style.transform = `scale(${size})`;
            
            // Background layer
            const sky = document.getElementById('sky');
            // Insert before ground to keep behind
            container.insertBefore(el, document.getElementById('ground'));

            clouds.push({
                x: window.innerWidth,
                elem: el
            });
        }

        function createParticles(x, y, type) {
            // Simple dirt particles
            for(let i=0; i<5; i++) {
                const p = document.createElement('div');
                p.classList.add('particle');
                p.style.left = `${x}px`;
                p.style.top = `${y}px`;
                p.style.backgroundColor = '#5C4033'; // Brown
                
                container.appendChild(p);
                
                // Animate
                const angle = Math.random() * Math.PI; // Upwards
                const speed = Math.random() * 5 + 2;
                let dx = Math.cos(angle) * speed;
                let dy = Math.sin(angle) * speed * -1;
                
                let life = 1;
                
                const pAnim = setInterval(() => {
                    dx *= 0.9; // Friction
                    dy += 0.5; // Gravity
                    
                    const currX = parseFloat(p.style.left);
                    const currY = parseFloat(p.style.top);
                    
                    p.style.left = `${currX + dx}px`;
                    p.style.top = `${currY + dy}px`;
                    p.style.opacity = life;
                    
                    life -= 0.05;
                    
                    if(life <= 0) {
                        clearInterval(pAnim);
                        p.remove();
                    }
                }, 20);
            }
        }

        function gameOver() {
            gameRunning = false;
            
            // High Score Logic
            if (score > highScore) {
                highScore = Math.floor(score);
                localStorage.setItem('chickenHighScore', highScore);
                highScoreEl.innerText = `HI: ${highScore} (NEW!)`;
                highScoreEl.style.color = '#55ff55';
            }

            finalScoreEl.innerText = Math.floor(score);
            gameOverScreen.style.display = 'flex';
            
            // Shake effect
            container.style.transform = 'translate(5px, 5px)';
            setTimeout(() => container.style.transform = 'translate(-5px, -5px)', 50);
            setTimeout(() => container.style.transform = 'translate(0, 0)', 100);
        }

        function resetGame() {
            // Clear screen
            obstacles.forEach(o => o.elem.remove());
            obstacles = [];
            clouds.forEach(c => c.elem.remove());
            clouds = [];
            
            // Reset stats
            score = 0;
            gameSpeed = START_SPEED;
            gameRunning = true;
            gameOverScreen.style.display = 'none';
            highScoreEl.style.color = '#ddd';
            
            // Reset Player logic overrides
            // Redefine jump mechanics to match update loop expectations
            // Correct logic: Jump adds positive velocity. Update loop subtracts gravity.
            // To make player jump up, dy must be positive.
            // To make gravity pull down, dy must decrease.
            
            // Let's fix the jump logic used in input vs update loop:
            // Input: dy = JUMP_FORCE (e.g. 15)
            // Loop: player.y += player.dy. dy -= GRAVITY.
            // This means positive dy moves UP.
            // CSS Bottom: 0 + y. So positive Y is UP.
            // Correct.
            
            // Let's double check constants:
            // GRAVITY = 0.6;
            // JUMP_FORCE = -12? No, should be +12 if positive Y is up.
            // Wait, usually in canvas Y=0 is top. Here we use CSS 'bottom'.
            // If bottom=0 is ground, increasing bottom moves UP.
            // So JUMP_FORCE should be POSITIVE.
            // GRAVITY should SUBTRACT from dy.
            
            // Let's fix the constants in the initialization above.
            // I will override them here just to be safe or fix in the code block.
            // *Self-correction*: I will edit the constants in the script block above before outputting.
            
            player.y = 0;
            player.dy = 0;
            player.isGrounded = true;
            
            update();
        }

        // Fix constants logic for CSS 'bottom' coordinate system
        // Redefining here for clarity in the final file generation, 
        // but I will ensure the main script block has:
        // JUMP_FORCE = 15; (Positive goes UP)
        // GRAVITY = 0.8; (Subtracts to go DOWN)
        
        // Actually, let's just overwrite the jump function logic in the main script block to match.
        
        // Start
        resetGame(); // This starts the loop

        // Override jump specifically for the CSS coordinate system
        // Y+ is UP (because bottom: Y px)
        window.jump = function() {
             if (player.isGrounded && gameRunning) {
                player.dy = 16; // Positive goes up
                player.isGrounded = false;
            }
        }
        
        // Override update physics
        window.update = function() {
            if (!gameRunning) return;

            score += 0.1;
            if (gameSpeed < MAX_SPEED) gameSpeed += SPEED_INC;
            scoreEl.innerText = `SCORE: ${Math.floor(score)}`;

            // Physics
            player.y += player.dy;
            if (!player.isGrounded) player.dy -= 0.8; // Gravity pulls down

            if (player.y <= 0) {
                player.y = 0;
                player.dy = 0;
                player.isGrounded = true;
            } else {
                player.isGrounded = false;
            }
            
            player.elem.style.bottom = `${GROUND_Y + player.y}px`;
            player.elem.style.transform = !player.isGrounded ? `rotate(-20deg)` : `rotate(0deg)`;

            // Obstacles
            if (Math.random() < 0.015 + (gameSpeed * 0.0001)) spawnObstacle();

            obstacles.forEach((obs, index) => {
                obs.x -= gameSpeed;
                obs.elem.style.left = `${obs.x}px`;

                // Collision
                const pRect = player.elem.getBoundingClientRect();
                const oRect = obs.elem.getBoundingClientRect();

                // Simple AABB with padding
                const padding = 10;
                if (
                    pRect.right - padding > oRect.left + padding &&
                    pRect.left + padding < oRect.right - padding &&
                    pRect.bottom - padding > oRect.top + padding
                ) {
                    gameOver();
                }

                if (obs.x < -100) {
                    obs.elem.remove();
                    obstacles.splice(index, 1);
                }
            });
            
            // Clouds
             if (Math.random() < 0.02) spawnCloud();
            clouds.forEach((c, i) => {
                c.x -= gameSpeed * 0.1;
                c.elem.style.left = `${c.x}px`;
                if(c.x < -100) {
                    c.elem.remove();
                    clouds.splice(i, 1);
                }
            });

            requestAnimationFrame(update);
        }

    </script>
</body>
</html>
